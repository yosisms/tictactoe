const WINNING_LINES = [\n  [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows\n  [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns\n  [0, 4, 8], [2, 4, 6], // diagonals\n];\n\n/**\n * Check if there's a winner on the board\n * @param {Array} squares - The game board\n * @returns {string|null} - 'X', 'O', or null\n */\nfunction checkWinner(squares) {\n  for (const line of WINNING_LINES) {\n    const [a, b, c] = line;\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return squares[a];\n    }\n  }\n  return null;\n}\n\n/**\n * Check if the board is full (draw)\n * @param {Array} squares - The game board\n * @returns {boolean}\n */\nfunction isBoardFull(squares) {\n  return squares.every(cell => cell !== null);\n}\n\n/**\n * Get all available (empty) positions\n * @param {Array} squares - The game board\n * @returns {Array} - Array of available indices\n */\nfunction getAvailableMoves(squares) {\n  return squares.reduce((moves, cell, index) => {\n    if (cell === null) moves.push(index);\n    return moves;\n  }, []);\n}\n\n/**\n * Minimax algorithm to find the best move\n * @param {Array} squares - The game board\n * @param {boolean} isMaximizing - Whether current player is maximizing\n * @param {number} depth - Current depth in the game tree\n * @param {number} alpha - Alpha value for pruning\n * @param {number} beta - Beta value for pruning\n * @returns {number} - Score of the position\n */\nfunction minimax(squares, isMaximizing, depth = 0, alpha = -Infinity, beta = Infinity) {\n  const winner = checkWinner(squares);\n  \n  // Terminal states\n  if (winner === 'O') return 10 - depth; // AI wins (sooner is better)\n  if (winner === 'X') return depth - 10; // Human wins (later is better for human)\n  if (isBoardFull(squares)) return 0; // Draw\n  \n  const availableMoves = getAvailableMoves(squares);\n  \n  if (isMaximizing) {\n    // AI's turn (O) - maximize score\n    let maxScore = -Infinity;\n    \n    for (const move of availableMoves) {\n      squares[move] = 'O';\n      const score = minimax(squares, false, depth + 1, alpha, beta);\n      squares[move] = null;\n      \n      maxScore = Math.max(maxScore, score);\n      alpha = Math.max(alpha, score);\n      \n      // Alpha-beta pruning\n      if (beta <= alpha) break;\n    }\n    \n    return maxScore;\n  } else {\n    // Human's turn (X) - minimize score\n    let minScore = Infinity;\n    \n    for (const move of availableMoves) {\n      squares[move] = 'X';\n      const score = minimax(squares, true, depth + 1, alpha, beta);\n      squares[move] = null;\n      \n      minScore = Math.min(minScore, score);\n      beta = Math.min(beta, score);\n      \n      // Alpha-beta pruning\n      if (beta <= alpha) break;\n    }\n    \n    return minScore;\n  }\n}\n\n/**\n * Find the best move for the AI\n * @param {Array} board - The game board\n * @returns {number} - Index of the best move\n */\nexport function findBestMove(board) {\n  const availableMoves = getAvailableMoves(board);\n  \n  // If board is empty, play center or corner for variety\n  if (availableMoves.length === 9) {\n    const goodFirstMoves = [4, 0, 2, 6, 8]; // Center or corners\n    return goodFirstMoves[Math.floor(Math.random() * goodFirstMoves.length)];\n  }\n  \n  // If only one move left, make it\n  if (availableMoves.length === 1) {\n    return availableMoves[0];\n  }\n  \n  let bestMove = -1;\n  let bestScore = -Infinity;\n  \n  // Try each available move and pick the best one\n  for (const move of availableMoves) {\n    const newBoard = [...board];\n    newBoard[move] = 'O'; // AI is 'O'\n    \n    const score = minimax(newBoard, false); // Next turn is human (minimizing)\n    \n    if (score > bestScore) {\n      bestScore = score;\n      bestMove = move;\n    }\n  }\n  \n  return bestMove;\n}\n\n/**\n * Get AI move with optional delay for better UX\n * @param {Array} board - The game board\n * @param {number} delayMs - Delay in milliseconds (default 400ms)\n * @returns {Promise<number>} - Promise that resolves to the move index\n */\nexport async function getAIMove(board, delayMs = 400) {\n  // Add slight delay to make AI feel more natural\n  await new Promise(resolve => setTimeout(resolve, delayMs));\n  return findBestMove(board);\n}\n